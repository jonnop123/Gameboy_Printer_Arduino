#include <avr/pgmspace.h>

#define delayMs 20

#define GBClock  8
#define GBIn  9
#define GBOut  10

// Command codes
#define GBInitialize  0x01
#define GBData 0x04
#define GBPrint 0x02
#define GBInquiry 0x0f

#define MarginNone 0x0
#define MarginMin 0x1
#define MarginMax 0xF

// GhIn needs 15kohm pullup (5v).
void setupPrinter(int in, int out, int clock)
{
  pinMode(out, OUTPUT);
  pinMode(clock, OUTPUT);
  pinMode(in, INPUT);           // set pin to input
  digitalWrite(in, HIGH);       // turn on pullup resistors
  digitalWrite(out, HIGH);       // turn on pullup resistors
}

void setup()
{
  setupPrinter(GBIn, GBOut, GBClock);
  Serial.begin(9600);
}

//uint8_t buffer[64];
uint8_t cmd;
uint16_t CRC;

// Each printable character is declared as an array of byte values in gameboy tile format. These were generated by the "GameBoy Tile Designer" program by H. Mulder.
// Each character is an 8x8 pixel tile. A pixel can be one of four colours: white, light grey, dark grey, black. Set GBTD to Gameboy classic 4 colours for use with the GB Printer.
// Click "Export" to save the tiles to a file containing the byte values.
// A single line is 160x16 pixels made of 40 tiles of 8x8 pixels. (20 tiles on each line for two small lines).
// GB Printer can store up to 9 lines for printing in its memory before printing.
// Web address for GBTD is http://www.devrs.com/gb/hmgd/gbtd.html

byte lowa[] = {0x00,0x00,0x00,0x00,0x38,0x38,0x44,0x44,0x3C,0x3C,0x44,0x44,0x4C,0x4C,0x34,0x34};
byte lowb[] = {0x00,0x00,0x20,0x20,0x20,0x20,0x38,0x38,0x24,0x24,0x24,0x24,0x24,0x24,0x38,0x38};
byte lowc[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x20,0x20,0x20,0x20,0x20,0x20,0x1C,0x1C};
byte lowd[] = {0x00,0x00,0x04,0x04,0x04,0x04,0x1C,0x1C,0x24,0x24,0x24,0x24,0x24,0x24,0x1C,0x1C};
byte lowe[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x24,0x24,0x3C,0x3C,0x20,0x20,0x1C,0x1C};
byte lowf[] = {0x00,0x00,0x0C,0x0C,0x10,0x10,0x38,0x38,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
byte lowg[] = {0x00,0x00,0x34,0x34,0x4C,0x4C,0x44,0x44,0x4C,0x4C,0x34,0x34,0x04,0x04,0x78,0x78};
byte lowh[] = {0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x38,0x38,0x24,0x24,0x24,0x24,0x24,0x24};
byte lowi[] = {0x00,0x00,0x00,0x00,0x10,0x10,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
byte lowj[] = {0x00,0x00,0x08,0x08,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x18,0x18};
byte lowk[] = {0x00,0x00,0x00,0x00,0x20,0x20,0x24,0x24,0x28,0x28,0x30,0x30,0x28,0x28,0x24,0x24};
byte lowl[] = {0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
byte lowm[] = {0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x92};
byte lown[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x3C,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24};
byte lowo[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x24,0x24,0x24,0x24,0x24,0x24,0x18,0x18};
byte lowp[] = {0x00,0x00,0x00,0x00,0x38,0x38,0x24,0x24,0x24,0x24,0x38,0x38,0x20,0x20,0x20,0x20};
byte lowq[] = {0x00,0x00,0x00,0x00,0x1C,0x1C,0x24,0x24,0x24,0x24,0x1C,0x1C,0x04,0x04,0x04,0x04};
byte lowr[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x20,0x20,0x20,0x20,0x20,0x20};
byte lows[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x20,0x20,0x18,0x18,0x04,0x04,0x38,0x38};
byte lowt[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x38,0x38,0x10,0x10,0x10,0x10,0x18,0x18};
byte lowu[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x24,0x24,0x24,0x24,0x24,0x18,0x18};
byte lowv[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x42,0x24,0x24,0x24,0x24,0x18,0x18,0x18,0x18};
byte loww[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x99,0x99,0x99,0x99,0x5A,0x5A,0x66,0x66,0x24,0x24};
byte lowx[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x24,0x18,0x18,0x18,0x18,0x24,0x24};
byte lowy[] = {0x00,0x00,0x00,0x00,0x44,0x44,0x28,0x28,0x28,0x28,0x10,0x10,0x10,0x10,0x20,0x20};
byte lowz[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x3C,0x04,0x04,0x18,0x18,0x20,0x20,0x3C,0x3C};
byte a[] = {0x00,0x00,0x18,0x18,0x18,0x18,0x24,0x24,0x24,0x24,0x3C,0x3C,0x42,0x42,0x42,0x42};
byte b[] = {0x00,0x00,0x78,0x78,0x44,0x44,0x44,0x44,0x78,0x78,0x44,0x44,0x44,0x44,0x78,0x78};
byte c[] = {0x00,0x00,0x38,0x38,0x64,0x64,0x40,0x40,0x40,0x40,0x40,0x40,0x64,0x64,0x38,0x38};
byte d[] = {0x00,0x00,0x78,0x78,0x4C,0x4C,0x44,0x44,0x44,0x44,0x44,0x44,0x4C,0x4C,0x78,0x78};
byte e[] = {0x00,0x00,0x7C,0x7C,0x40,0x40,0x40,0x40,0x7C,0x7C,0x40,0x40,0x40,0x40,0x7C,0x7C};
byte f[] = {0x00,0x00,0x7C,0x7C,0x40,0x40,0x40,0x40,0x7C,0x7C,0x40,0x40,0x40,0x40,0x40,0x40};
byte g[] = {0x00,0x00,0x3C,0x3C,0x64,0x64,0x40,0x40,0x4C,0x4C,0x44,0x44,0x64,0x64,0x3C,0x3C};
byte h[] = {0x00,0x00,0x42,0x42,0x42,0x42,0x42,0x42,0x7E,0x7E,0x42,0x42,0x42,0x42,0x42,0x42};
byte i[] = {0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08};
byte j[] = {0x00,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x3C,0x3C};
byte k[] = {0x00,0x00,0x24,0x24,0x28,0x28,0x28,0x28,0x30,0x30,0x28,0x28,0x24,0x24,0x24,0x24};
byte l[] = {0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3C,0x3C};
byte m[] = {0x00,0x00,0xC3,0xC3,0xC3,0xC3,0xA5,0xA5,0xA5,0xA5,0x99,0x99,0x99,0x99,0x99,0x99};
byte n[] = {0x00,0x00,0x64,0x64,0x64,0x64,0x54,0x54,0x54,0x54,0x4C,0x4C,0x4C,0x4C,0x4C,0x4C};
byte o[] = {0x00,0x00,0x38,0x38,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x38};
byte p[] = {0x00,0x00,0x38,0x38,0x24,0x24,0x24,0x24,0x38,0x38,0x20,0x20,0x20,0x20,0x20,0x20};
byte q[] = {0x38,0x38,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x3C,0x3C,0x02,0x02};
byte r[] = {0x00,0x00,0x38,0x38,0x24,0x24,0x24,0x24,0x38,0x38,0x24,0x24,0x24,0x24,0x24,0x24};
byte s[] = {0x00,0x00,0x1C,0x1C,0x24,0x24,0x20,0x20,0x18,0x18,0x04,0x04,0x24,0x24,0x38,0x38};
byte t[] = {0x00,0x00,0x7C,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
byte u[] = {0x00,0x00,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x38};
byte v[] = {0x00,0x00,0x42,0x42,0x66,0x66,0x24,0x24,0x24,0x24,0x3C,0x3C,0x18,0x18,0x18,0x18};
byte w[] = {0x00,0x00,0x99,0x99,0x99,0x99,0xB9,0xB9,0xAA,0xAA,0x66,0x66,0x66,0x66,0x66,0x66};
byte x[] = {0x00,0x00,0x42,0x42,0x24,0x24,0x3C,0x3C,0x18,0x18,0x3C,0x3C,0x24,0x24,0x42,0x42};
byte y[] = {0x00,0x00,0x44,0x44,0x28,0x28,0x28,0x28,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10};
byte z[] = {0x00,0x00,0x7C,0x7C,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x20,0x20,0x7C,0x7C};
byte space[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
byte comma[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x10,0x10};
byte fullstop[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x00,0x00};
byte exclaimation[] = {0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x10,0x10,0x00,0x00};
byte question[] = {0x00,0x00,0x38,0x38,0x44,0x44,0x04,0x04,0x18,0x18,0x10,0x10,0x00,0x00,0x10,0x10};
byte zero[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x18,0x18};
byte one[] = {0x00,0x00,0x10,0x10,0x30,0x30,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x38};
byte two[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x3C,0x3C};
byte three[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x04,0x04,0x18,0x18,0x04,0x04,0x24,0x24,0x18,0x18};
byte four[] = {0x00,0x00,0x08,0x08,0x18,0x18,0x28,0x28,0x48,0x48,0x7C,0x7C,0x08,0x08,0x08,0x08};
byte five[] = {0x00,0x00,0x3C,0x3C,0x20,0x20,0x20,0x20,0x3C,0x3C,0x04,0x04,0x24,0x24,0x18,0x18};
byte six[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x20,0x20,0x38,0x38,0x24,0x24,0x24,0x24,0x18,0x18};
byte seven[] = {0x00,0x00,0x3C,0x3C,0x04,0x04,0x08,0x08,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10};
byte eight[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x24,0x24,0x18,0x18,0x24,0x24,0x24,0x24,0x18,0x18};
byte nine[] = {0x00,0x00,0x18,0x18,0x24,0x24,0x24,0x24,0x1C,0x1C,0x04,0x04,0x24,0x24,0x18,0x18};

void loop()
{
  cmd = Serial.read();
  ///////////////////////////////////////////////////////////
  if (cmd == '?')
  {
    if (sendInitialize()) {
      getStatusCode();
      Serial.print('1');
    } 
    else {
      Serial.print('0');
    }
  }
  ///////////////////////////////////////////////////////////
  if(cmd == 't') // Sending the character 't' initiates the sending checks. Sending format is: tTEXT/ where 't' and '/' are prefixed and suffixed to the text to be printed.
                 // E.G. sending the string "tHello my name is Jon/" over the arduino serial port will print the text: "Hello my name is Jon"
  {
    char printline[40][9]; // This variable saves the string received over the serial port for printing. The following code splits it into lines of length 20 characters across 9 lines.
    for(int temp1=0;temp1<9;temp1++)
    {
      for(int temp2=0;temp2<40;temp2++)
      {
        printline[temp1][temp2] = 0;
      }
    }
    int serialread,charpos=0,linepos=0;
    while(1)
    {
      serialread = Serial.read();
      if(serialread == '/') // Sending the character '/' signals the end of character input. GB Printer should now start printing.
      {
        for(charpos;charpos<40;charpos++) // Set the elements of the rest of the line to zero to avoid the contents of the previously entered string being repeated
        {
          printline[charpos][linepos] = 0;
        }
        break;
      }
      if(serialread != -1)
      {
        printline[charpos][linepos] = serialread;
        charpos++;
      }
      if(charpos == 40)
      {
        charpos = 0;
        linepos++;
      }
    }
    /////////////////////////////////////////////////////
    Serial.println("Init");
    sendInitialize();
    getStatusCode();
    /////////////////////////////////////////////////////
    // Print the contents of the printline[][] array for debugging
    Serial.println("####################");
    for(int temp1=0;temp1<9;temp1++)
    {
      for(int temp2=0;temp2<40;temp2++)
      {
        Serial.print(printline[temp2][temp1]);
      }
      Serial.print("\n");
    }
    Serial.println("####################");
    /////////////////////////////////////////////////////
    int linecount = linepos+1;
    int lineoffset = 0;
    /////////////////////////////////////////////////////
    // SENDING DATA STARTS HERE
    /////////////////////////////////////////////////////
    // Following code deconstructs the contents of the "printline[][]" array and sends it character by character to the GB Printer.
    for(lineoffset=0;lineoffset<linecount;lineoffset++)
    {
    CRC = 0;
    Serial.println("Data");
    CRC += beginData();
    int count = 0,filledbytes = 0;
    for(count = 0;count < 40;count++)
    {
      if(printline[count][lineoffset] == 'a')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowa[count1];
          GBSerialOut(lowa[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'b')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowb[count1];
          GBSerialOut(lowb[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'c')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowc[count1];
          GBSerialOut(lowc[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'd')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowd[count1];
          GBSerialOut(lowd[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'e')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowe[count1];
          GBSerialOut(lowe[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'f')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowf[count1];
          GBSerialOut(lowf[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'g')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowg[count1];
          GBSerialOut(lowg[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'h')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowh[count1];
          GBSerialOut(lowh[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'i')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowi[count1];
          GBSerialOut(lowi[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'j')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowj[count1];
          GBSerialOut(lowj[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'k')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowk[count1];
          GBSerialOut(lowk[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'l')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowl[count1];
          GBSerialOut(lowl[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'm')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowm[count1];
          GBSerialOut(lowm[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'n')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lown[count1];
          GBSerialOut(lown[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'o')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowo[count1];
          GBSerialOut(lowo[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'p')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowp[count1];
          GBSerialOut(lowp[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'q')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowq[count1];
          GBSerialOut(lowq[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'r')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowr[count1];
          GBSerialOut(lowr[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 's')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lows[count1];
          GBSerialOut(lows[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 't')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowt[count1];
          GBSerialOut(lowt[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'u')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowu[count1];
          GBSerialOut(lowu[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'v')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowv[count1];
          GBSerialOut(lowv[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'w')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += loww[count1];
          GBSerialOut(loww[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'x')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowx[count1];
          GBSerialOut(lowx[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'y')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowy[count1];
          GBSerialOut(lowy[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'z')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += lowz[count1];
          GBSerialOut(lowz[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'A')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += a[count1];
          GBSerialOut(a[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'B')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += b[count1];
          GBSerialOut(b[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'C')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += c[count1];
          GBSerialOut(c[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'D')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += d[count1];
          GBSerialOut(d[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'E')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += e[count1];
          GBSerialOut(e[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'F')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += f[count1];
          GBSerialOut(f[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'G')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += g[count1];
          GBSerialOut(g[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'H')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += h[count1];
          GBSerialOut(h[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'I')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += i[count1];
          GBSerialOut(i[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'J')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += j[count1];
          GBSerialOut(j[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'K')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += k[count1];
          GBSerialOut(k[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'L')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += l[count1];
          GBSerialOut(l[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'M')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += m[count1];
          GBSerialOut(m[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'N')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += n[count1];
          GBSerialOut(n[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'O')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += o[count1];
          GBSerialOut(o[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'P')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += p[count1];
          GBSerialOut(p[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'Q')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += q[count1];
          GBSerialOut(q[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'R')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += r[count1];
          GBSerialOut(r[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'S')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += s[count1];
          GBSerialOut(s[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'T')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += t[count1];
          GBSerialOut(t[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'U')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += u[count1];
          GBSerialOut(u[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'V')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += v[count1];
          GBSerialOut(v[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'W')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += w[count1];
          GBSerialOut(w[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'X')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += x[count1];
          GBSerialOut(x[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'Y')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += y[count1];
          GBSerialOut(y[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == 'Z')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += z[count1];
          GBSerialOut(z[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == ' ')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += space[count1];
          GBSerialOut(space[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == ',')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += comma[count1];
          GBSerialOut(comma[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '.')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += fullstop[count1];
          GBSerialOut(fullstop[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '!')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += exclaimation[count1];
          GBSerialOut(exclaimation[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '?')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += question[count1];
          GBSerialOut(question[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '0')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += zero[count1];
          GBSerialOut(zero[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '1')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += one[count1];
          GBSerialOut(one[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '2')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += two[count1];
          GBSerialOut(two[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '3')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += three[count1];
          GBSerialOut(three[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '4')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += four[count1];
          GBSerialOut(four[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '5')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += five[count1];
          GBSerialOut(five[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '6')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += six[count1];
          GBSerialOut(six[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '7')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += seven[count1];
          GBSerialOut(seven[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '8')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += eight[count1];
          GBSerialOut(eight[count1]);
          filledbytes++;
        }
      }
      if(printline[count][lineoffset] == '9')
      {
        for(int count1=0; count1<16; count1++)
        {
          CRC += nine[count1];
          GBSerialOut(nine[count1]);
          filledbytes++;
        }
      }
    }
    // Pad the rest of the GB Printer's 640 byte line buffer with zeros so it will print the line
    for(filledbytes;filledbytes<640;filledbytes++)
    {
      CRC += 0x00;
      GBSerialOut(0x00);
    }

    if(endData(CRC)) //0x27E06
    { 
      Serial.println("Data sent");
    }
    printStatusCode(-1);
    }
    ////////////////////////////////////////////////
    // SENDING DATA ENDS HERE
    ////////////////////////////////////////////////
    // Commands telling the GB Printer to print the contents of its buffer
    Serial.println("Inq");        
    sendInquiry();
    Serial.println("Data");    
    GBPCommand(GBData,0);
    printStatusCode(-1);
    Serial.println("Print");
    sendPrint(1,3,0xE4,0x40);
    printStatusCode(-1);
  }
}

void printStatusCode(int result)
{
  if(result<0)
  {
    result = getStatusCode();
  }
}

// 8 clock intervals (8bits per packet)
uint8_t GBSerialOut(uint8_t command) {
  uint8_t gbReplyy=0;
  for (uint8_t clock=0;  clock<8;  ++clock) {
    gbReplyy <<= 1;			// Shift Printer gbReplyy
    digitalWrite(GBClock, 0);           // Send clock signal

    if((command << clock) & 0x80){
      digitalWrite(GBOut, 1); // Write out to printer
    }
    else{ 
      digitalWrite(GBOut, 0);
    }

    delayMicroseconds(delayMs);		// Wait 20-60us
    digitalWrite(GBClock, 1);            // End clock
    if(digitalRead(GBIn))
    {
      gbReplyy |= 1;    // Fetch printer gbReplyy
    }
    delayMicroseconds(delayMs);		// Wait 20-60us
  }

  delayMicroseconds(delayMs);		// Wait 20-60us

  return gbReplyy;

}

/*
A command packet consists of the following four parts: a Synchronization mark, a Header, a body, and a Checksum, in this order.
 */

// Send a command packet to GB Printer
boolean GBPCommand(uint8_t command, uint16_t bodyLength) {

  boolean result = false;
  sendSync();
  sendHeader(command, 0x00, bodyLength); 


  // 0x88 // Magic
  // 0x33 // Magic
  // 0x01 // Command
  // 0x00 // Length
  // 0x00 //Length
  // 0x01 // Sum of everything bar magic packet

  sendChecksum(bodyLength + command); // GBPCommand CRC
  result = getAcknowledgement();

  return result;
}

// This sequence indiciates the beginning of a command packet
void sendSync()
{
  // Magic hytes
  GBSerialOut(0x88);	//10001000			
  GBSerialOut(0x33);    //00110011
}

/*
A Header consists of four bytes. 
 The first byte in the Header is a command code, and the second is a compression indicator.
 Third and fourth bytes form a 16 bit integer (in LSB-first byte order, i.e., the third byte is the lower 8 bits and the fourth the higher) 
 representing the length of the body of the command packet in bytes. 
 This value may be zero to indicate an empty body. 
 */
uint16_t sendHeader(uint8_t commandCode, uint8_t compressionIndicator, uint16_t bodyLength)
{
  GBSerialOut(commandCode);            // 0000 xxxx
  GBSerialOut(compressionIndicator);   // 0000 000x
  // LSB (send as two hytes)
  // 0000 0000
  // 0000 0000
  GBSerialOut(bodyLength); // Lower 8 hits
  GBSerialOut(bodyLength>>8); // Higher 8 hits

  return commandCode + compressionIndicator + (uint8_t)bodyLength + ((uint8_t)(bodyLength>>8));
}

/*
A Checksum is a two-byte (16 bit) value to verify a command packet is received properly.
 It is always appended at the end of a command packet. The Checksum is a 16 bit arithmetic 
 sum over bytes in the command packet, excluding the Synchronization marker (i.e., 0x83 and 0x33 at the beginning of the packet) 
 and the Checksum, regarding each byte as an eight-bit unsigned integer. 
 */

void sendChecksum(uint16_t checksum)
{
  // LSB (send as two hytes)
  // 0000 0000
  // 0000 0000  
  GBSerialOut(checksum); // Lower 8 bits
  GBSerialOut(checksum>>8); // Higher 8 bits
}

/*
GB sends one Initialize command when it starts printing a page. If it attempts to print several pages in sequence, one Initialize command is sent for each page. 
 
 Unlike other commands, a Print command requires long time to complete, since the command requires some mechanical actions to complete.
 GB games that print usually issue Inquiry commands periodically after a Print command to wait for the command to complete. 
 */
boolean sendInitialize()
{
  return GBPCommand(GBInitialize, 0);
}

/*
A command packet whose command code is set to 0x0F is an Inquiry command. The compression indicator of the Inquiry command is set to zero (0x00.) 
 The length field is always set to zero (0x00 0x00,) to indicate the body in the command is empty. The purpose of Inquiry command is to make GB Printer to notify its status to the GB. So, this command is suitahle to be used after a Print command or before an Initialize command. 
 However, unlike other commands, Inquiry command may be issued at any time. The GB Printer is expected to respond to an Inquiry command always. 
 
 */
uint8_t sendInquiry()
{
  GBPCommand(GBInquiry, 0);
  return getStatusCode();
}

/*
A plain printing Data command is used to transmit (a part of) printing image from GB to Printer. 
 The compression indicator in Header is set to zero (0x00.) The length field in Header is set to 0x280, or 640 in decimal. 
 Since 16 bit values are transmitted in LSB-first hyte order, it is actually transmitted as 0x80 0x02.
 The body in plain printing Data command represents a band (160x16 dots or 20x2 tiles) of printing image in plain (uncompressed) format. 
 */
uint16_t beginData() // returns checksum
{
  sendSync();
  return sendHeader(GBData, 0x00, 0x280); // Grab checksum
}

/*
One empty Data command is sent after the last printing Data command for a page and before the Print command for the page. 
 The purpose of this command is unknown. 
 */
boolean endData(uint16_t checksum)
{
  sendChecksum(checksum);
  return getAcknowledgement();
}

boolean endPage()
{
  GBPCommand(GBData, 0);
  return getStatusCode() == 0x08;
}


// Any value between 0x1 and 0xF is for some margin between minimum and maximum, apparently proportional to the specified value. 
/*
  A Print command is issued after sufficient number of printing Data commands have heen issued. 
 When the Print command is received, the GB Printer physically starts printing. 
 In other words, printing image data sent between the last Initialize command and this Print command collectively form a page. 
 */
boolean sendPrint(uint8_t leftMargin, uint8_t rightMargin, uint8_t palette, uint8_t exposure)
{
  uint16_t CRC = 0;
  sendSync();
  CRC += sendHeader(GBPrint, 0x00, 0x04); // body in a Print command is always four bytes in length.

  CRC += 0x01;
  GBSerialOut(0x01); // The first byte is always set to 0x01, and its purpose is unknown. 


  // The second byte represents margins before and after the page
  // ----- The margins byte (the second byte in Body) is divided into two four-bit values.
  GBSerialOut((leftMargin << 4) + rightMargin);



  // The third byte defines the palette to be used to render the page
  GBSerialOut(palette); // Palette (11100100: Noir, FoncÃ©, Clair, Blanc)

  // The fourth byte represents the dense of ink for printing (or the heat at the printing head since real GB Printer is a thermal prin
  // er.) 
  GBSerialOut(exposure);// Expo (7 bits)

  CRC += ((leftMargin << 4) + rightMargin) + palette + exposure;

  sendChecksum(CRC);

  return getAcknowledgement();
}


/*
A band consists of 40 tiles. A tile is an image consisting of 8x8 dots. Color of each dot is specified by a two-bit value, so a dot can be a color out of four. Actually, GB Printer prints only greyscale (monochrome) image, so possible colors are: white, light grey, dark grey, and black. A tile is represented by 16 bytes of data. The format of a tile is exactly same as that of GB display tile pattern, such as background tile, window tile, or sprite tile. 
 */

// A band consists of two strips (2 strips, 20x strip. 40 tiles)
void sendBand()
{
  for(int i=0; i<2; ++i) sendStrip();
}

// 160 pixels wide / 8 = 20 tiles
void sendStrip()
{
  for(int i=0; i<20; ++i) sendTestTile();
}

// A tile consists of 16 bytes
// 8x8
void sendTestTile()
{
  for(int i=0; i<16;++i)
  {
    GBSerialOut(0xFF);
  }
}

/*
An acknowledgement code is set (by GB Printer) to either 0x80 or 0x81. 
 The difference of those two values is unsure at this moment. 
 */
boolean getAcknowledgement()
{
  uint8_t ack = GBSerialOut(0); // Wait for confirmation
  return (ack==0x80 || ack == 0x81); // Good otherwise timeout
}


#define GBStatus_LowBattery 0x80
#define GBStatus_TempBad 0x40
#define GBStatus_Jam 0x20
#define GBStatus_Busy 0x10
#define GBStatus_Good 0x00
/*
  A status code is a bitmap to indicate various Printer statuses. It has bit-by-bit meanings.
 */
uint8_t getStatusCode()
{
  return GBSerialOut(0); // Wait for confirmation  
}
